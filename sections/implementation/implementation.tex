\section{Design and Implementation}
The upcoming Design and Implementation chapter describes possible countermeasures to the previously shown attacks. The best working one is then being implemented.
\label{sec:implementation}
The previous chapter showed that many different attacks without exist, that can't be prevented by the existing defenses. These attacks can be classified into two groups that have to be handled separately in order to increase security on the target platform. Attacks to the process virtual memory that have to use \syscall{WriteProcessMemory}, which form the first group and attacks that are relying on a DLL load during their initialization to execute their malicious code from inside, which form the second group. This classification makes it possible to design effective countermeasures that can't be circumvented. 

\subsection{Blocking \syscall{WriteProcessMemory} with a kernel mode driver}
\begin{figure}[!htbp]
\centering
\includegraphics[angle=90,scale=0.6]{sections/implementation/interaction.png}
\caption{The interaction of the drivers components}
\label{fig:interaction}
\end{figure}
The newly created problem with the modified ACL can be solved by creating a driver running in kernel-mode. As reading memory, checking files and running processes are a common problem when writing anti virus software, Microsoft introduced object manager routines since Windows Vista to provide an efficient way of reacting onto these events. A driver will then use \syscall{ObRegisterCallbacks} to get notified whenever processes are created, files are opened and images (DLLs and EXEs) are loaded. This functionality offers the programmer to create a pre- and post-execution callback function, that gets called whenever a process tries to receive a process handle. Microsoft offers an example driver using \syscall{ObRegisterCallbacks} at \cite{github_obcallback} and shows how to modify the requested process handle permissions to prevent termination by other applications such as the task manager. 

In order to protect chrome, the same actions described earlier will now be taken from inside the driver. Newly created process handles will be restricted to non virtual memory modifying permissions and the existing problem with inter process communication can be resolved by not restricting chromes child processes explicitly and giving them a full access handle. Appendix \ref{appendix:driver} shows an implemented driver to fulfill the requirements.

However, a naive implementation that just checks for process' executable file name may result in an access gain for the attacker. The injecting process simply has to be named chrome.exe and can gain access to the original chrome.exe. In this case, the implementation restricts outside access regardless of the given process name successfully. Children and parent processes ids (pids) are stored inside two separate tables that are on access checked if they contain target and source process ids. The driver is using a dynamic list structure, so that an unlimited number of processes can be tracked. Finally the check for access rights can be done by finding a given pid inside the defined lists and returning a hash value, which uniquely identifies the process. 

A good hash for this tree is the parent pid, as the process hierarchy is tracked inside the list. Only if both find operations result in a match of the returned pids, access is granted and no restriction is applied. Entries of the list (parent or child process) will get removed as soon as they exit, so that the remaining list is kept clean from garbage and reassignments of the same pid don't lead to a security hole.

\subsection{Blocking DLL Injection with a kernel mode driver}
As previously stated, the resulting implementation already uses a kernel mode driver to prevent \syscall{WriteProcessMemory} calls. It is therefore a suitable start point to prevent DLL injections without being required to hook into the kernel. The Windows API for drivers offers the \syscall{PsSetLoadImageNotfiyRoutine} function call, to register a callback function that is executed whenever a DLL is mapped into memory. During the function call, the process is in a suspended state and thus execution of the DLL hasn't begun. However, this entry point for DLL load prevention is not optimal, as this function call occurs after the DLL was already mapped into memory and a pre loading callback would be better to use in this situation. Unfortunately, this callback function does not exist so far, so the implementation has to rely on the post load callback.

To make use of \syscall{PsSetLoadImageNotifyRoutine}, the IRQ Level may not be changed, because otherwise it can lead to a deadlock or even make the system crash in a blue screen of death. Most notably is the fact that the function call occurs on IRQ Level \syscall{PASSIVE\_LEVEL} and special kernel mode APCs are disabled. This is at first a major limitation to naive implementations. Opening and reading file calls will not complete, as the underlying APC event is not sent, thus in a naive implementation, reading a file seems impossible at a first glance. The reason for the disabled special kernel mode APCs is a previous call to the \syscall{KeEnterGuardedRegion} function, so a call to \syscall{KeLeaveGuardedRegion} can enable APC events again. However, this shouldn't be done here, as the result turns out to be unpredictable and leading to random deadlocks or failing accesses on files.

By having a deeper look at the windows kernel with a kernel debugger, a solution can be obtained by using a second running thread, a so called work item, which execution is handled separately by the system. The advantage of this are the enabled special kernel mode APCs and the possibility to freely change the IRQL during execution. One major disadvantage of this way is, that some sort of thread synchronization between the work item and the initial callback function has to be introduced and thus resulting into driver typical busy waiting, which is still faster than non busy waiting and eventually occurring context changes. 

A file handle can now be obtained and from the file data a sha256 \cite{eckert2014sicherheit} hash is generated, which is used later to compare it to a known whitelist of DLL files. The Windows API offers several different ways of obtaining a valid file handle with functions like \syscall{ZwOpenFile} or \syscall{ObOpenObjectByPointer}. The second function \syscall{ObOpenObjectByPointer} will generate a handle from a given pointer to an object. That is exactly what can be found inside the input parameters of the \syscall{PsSetLoadImageNotifyRoutine} callback. The image info can be extended to obtain a file object, and the \syscall{ObOpenObjectByPointer} function can then be used to obtain a handle from this file object. Though, this didn't work in all cases and lead to "random" results. 

If a file was opened a first time, \syscall{ObOpenObjectByPointer} will succeed and return a valid file handle. Subsequent calls to the same file lead to error \syscall{STATUS\_UNSUCCESSFUL} for no obvious reason. Kernel-debugging allowed to find the reason of failure, which is an internal call to \syscall{ObpIncrementHandleCount} that returns \syscall{STATUS\_UNSUCCESFUL}. There can be found nothing with respect to this problem and it might be a bug inside the windows kernel itself. 

Therefore, \syscall{ObOpenObjectByPointer} can't be used and only \syscall{ZwOpenFile} works as expected, but gives a new problem, the full file path. Path constructions is required, but will overall work and allow reading of all loaded DLL files. Finally, the resulting sha256 hash can be calculated and compared to the whitelist and if no match is found, actions can be taken to prevent the DLL from executing. 

An initial thought could be to undo the internal \syscall{ZwMapViewOfSection} / \syscall{NtMapViewOfSection} function that loaded the DLL into memory by calling it's counter pair \syscall{ZwUnmapViewOfSection} / \syscall{NtUnmapViewOfSection} and thus removing the DLL from memory. The idea is great, but will not succeed as a special lock is hold, the LdrLoadLoaderLock, that can't be accessed at this point of code. Calling the functions regardless will deadlock the driver and soon after deadlock the whole system.

Thus, the DLL will only get patched, rendering it, although still residing in memory, useless. To do that, three points in memory receive modifications: the entry point address, the \syscall{DOS MZ header}, which describes the file format of a DLL with many meta information and the entry point function. The entry point address is set to NULL, the entry point function will get patched with a single \syscall{ret} (0xC3) instruction to prevent execution and the memory containing the \syscall{DOS MZ header} will get zeroed. All three steps guarantee, that nothing will be able to execute from this memory mapped DLL file and thus preventing the typical DLL injections from \syscall{SetWindowsHookEx}, the registry or other techniques.