\section{Design and Implementation}
The upcoming Design and Implementation chapter describes possible countermeasures to the previously shown attacks. The best working one is then being implemented.
\label{sec:implementation}
The previous chapter showed that many different attacks without exist, that can't be prevented by the existing defenses. These attacks can be classified into two groups that have to be handled separately in order to increase security on the target platform. Attacks to the process virtual memory that have to use \syscall{WriteProcessMemory}, which form the first group and attacks that are relying on a DLL load during their initialization to execute their malicious code from inside, which form the second group. This classification makes it possible to design effective countermeasures that can't be circumvented. 

\subsection{Blocking \syscall{WriteProcessMemory} with a DACL}
\label{sec:implementation_dacl}
Most injection techniques call at some point in time the two important \syscall{OpenProcess} and subsequently \syscall{WriteProcessMemory} functions to inject code into or modify memory in the remote process. It is not possible to easily intercept these calls from inside a user-mode process, as the the process is suspended during the \syscall{WriteProcessMemory} function call. Instead, one might try to prevent this function call from happening and thus preventing the exploit by just limiting the process access rights and removing the required permissions to call virtual memory modifying functions like \syscall{WriteProcessMemory} and \syscall{ReadProcessMemory}. The \syscall{OpenProcess} function will then not be able to return a handle with the required permissions and calls to \syscall{WriteProcessMemory} will fail with \syscall{STATUS\_ACCESS\_DENIED} error code.

Implementing this approach works great in a test application seen in \ref{appendix:dacl}, however once added to Google Chrome, Chrome malfunctions and is no longer usable. The reason for that is Chrome's process hierarchy and the dependence on inter process communication with \syscall{WriteProcessMemory} and \syscall{ReadProcessMemory}. Compiling chromium with the shown DACL Deny code results in a running executable that is at the end not fully functioning. The content of the browser is not displayed and opening web pages fail, returning to the current open about:blank page immediately. Therefore a different approach has to be taken to limit virtual memory modification with \syscall{WriteProcessMemory}.

\subsection{Blocking \syscall{WriteProcessMemory} with a kernel mode driver}
\begin{figure}[h]
\centering
\includegraphics[angle=90,scale=0.6]{sections/implementation/interaction.png}
\caption{The interaction of the drivers components.}
\label{fig:interaction}
\end{figure}
The newly created problem with the modified ACL can be solved by creating a driver running in kernel-mode. As reading memory, checking files and running processes are a common problem when writing anti virus software, Microsoft introduced object manager routines since Windows Vista to provide an efficient way of reacting onto these events. A driver will then use \syscall{ObRegisterCallbacks} to get notified whenever processes are created, files are opened and images (DLLs and EXEs) are loaded. This functionality offers the programmer to create a pre- and post-execution callback function, that gets called whenever a process tries to receive a process handle. Microsoft offers an example driver using \syscall{ObRegisterCallbacks} at \cite{github_obcallback} and shows how to modify the requested process handle permissions to prevent termination by other applications such as the task manager. 

In order to protect chrome, the same actions described earlier will now be taken from inside the driver. Newly created process handles will be restricted to non virtual memory modifying permissions and the existing problem with inter process communication can be resolved by not restricting chromes child processes explicitly and giving them a full access handle. \ref{appendix:driver} shows an implemented driver to fulfill the requirements. A demonstration video of the resulting implementation can be found in the contained digital materials.

However, a naive implementation that just checks for process' executable file name may result in an access gain for the attacker. The injecting process simply has to be named chrome.exe and can gain access to the original chrome.exe. In this case, the implementation restricts outside access regardless of the given process name successfully. Children and parent processes ids (pids) are stored inside two separate tables that are on access checked if they contain target and source process ids. The driver is using a dynamic list structure, so that an unlimited number of processes can be tracked. Finally the check for access rights can be done by finding a given pid inside the defined lists and returning a hash value, which uniquely identifies the process. 

A good hash for this tree is the parent pid, as the process hierarchy is tracked inside the list. Only if both find operations result in a match of the returned pids, access is granted and no restriction is applied. Entries of the list (parent or child process) will get removed as soon as they exit, so that the remaining list is kept clean from garbage and reassignments of the same pid don't lead to a security hole. 

\subsection{Blocking DLL Injection by hooking \syscall{LoadLibrary}}
For the second classification group, the DLL based injections, access control lists as explained in Section \ref{sec:sd} can't be used, as it is unknown which DLLs are malicious and thus, for which DLL files an ACL entry should be set to prevent execution. Additionally, the user of a file has always full permissions to change the ACL entry, so that any permission restriction can be easily undone. Thus, the ACL turns out to be useless and doesn't prevent loading of DLLs in all cases. 

Therefore a better approach is, hooking the \syscall{LoadLibrary} function, by detouring the function call, as shown in Figure \ref{fig:detours}. The application will then get called every time a DLL is loaded and can return early with a \syscall{STATUS\_ACCCESS\_DENIED} error code, if the to be loaded DLL is unwanted. However, this function might not be called in all DLL load cases, as the hook is placed after the process has started running. As a local hook is not enough to detect DLL loads before the hook is installed, a deeper system hook is needed. Unfortunately, this requires patching the system call table and is prevented on 64 bit systems due to PatchGuard since Windows 7. Therefore, a different approach needs to be taken to catch all cases.

\subsection{Blocking DLL Injection with a kernel mode driver}
As previously stated, the resulting implementation already uses a kernel mode driver to prevent \syscall{WriteProcessMemory} calls. It is therefore a suitable start point to prevent DLL injections without being required to hook into the kernel. The Windows API for drivers offers the \syscall{PsSetLoadImageNotfiyRoutine} function call, to register a callback function that is executed whenever a DLL is mapped into memory. During the function call, the process is in a suspended state and thus execution of the DLL hasn't begun. However, this entry point for DLL load prevention is not optimal, as this function call occurs after the DLL was already mapped into memory and a pre loading callback would be better to use in this situation. Unfortunately, this callback function does not exist so far, so the implementation has to rely on the post load callback.

To make use of this function, the MSDN documentation has to be read carefully, as not following it will lead to a deadlock or even make the system crash in a blue screen of death. Most notably is the fact that the function call occurs on IRQ Level \syscall{PASSIVE\_LEVEL} and special kernel mode APCs are disabled. This is at first a major limitation to naive implementations. Opening and reading file calls will not complete, as the underlying APC event is not sent, thus in a naive implementation, reading a file seems impossible at a first glance. The reason for the disabled special kernel mode APCs is a previous call to the \syscall{KeEnterGuardedRegion} function, so a call to \syscall{KeLeaveGuardedRegion} can enable APC events again. However, this shouldn't be done here, as the result turns out to be unpredictable and leading to random deadlocks or failing accesses on files.

By having a deeper look at the windows kernel with a kernel debugger, a solution can be obtained by using a second running thread, a so called work item, which execution is handled separately by the system. The advantage of this are the enabled special kernel mode APCs and the possibility to freely change the IRQL during execution. One major disadvantage of this way is, that some sort of thread synchronization between the work item and the initial callback function has to be introduced and thus resulting into driver typical busy waiting, which is still faster than non busy waiting and eventually occurring context changes. 

A file handle can now be obtained and from the file data a sha256 hash is generated, which is used later to compare it to a known whitelist of DLL files. Although gaining a file handle seems easy, it is in fact not! The Windows API offers several different ways of obtaining a valid file handle with functions like \syscall{ZwOpenFile} or \syscall{ObOpenObjectByPointer}. The second function \syscall{ObOpenObjectByPointer} will generate a handle from a given pointer to an object. Luckily, that's exactly what can be found inside the input parameters of the \syscall{PsSetLoadImageNotifyRoutine} callback. The image info can be extended to obtain a file object, and the \syscall{ObOpenObjectByPointer} function can then be used to obtain a handle from this file object. Though, this didn't work in all cases and lead to "random" results. 

If a file was opened a first time, \syscall{ObOpenObjectByPointer} will succeed and return a valid file handle. Subsequent calls to the same file lead to error \syscall{STATUS\_UNSUCCESSFUL} for no obvious reason. Kernel-debugging allowed to find the reason of failure, which is an internal call to \syscall{ObpIncrementHandleCount} that returns \syscall{STATUS\_UNSUCCESFUL}. There can be found nothing with respect to this problem and it might be a bug inside the windows kernel itself. 

Therefore, \syscall{ObOpenObjectByPointer} can't be used and only \syscall{ZwOpenFile} works as expected, but gives a new problem, the full file path. That's surprising, as typical callback routines always get the full filepath as input parameter, \syscall{PsSetLoadImageNotifyRoutine} does not! Some path constructions is required, but will overall work and allow reading of all loaded DLL files. Finally, the resulting sha256 hash can be calculated and compared to the whitelist and if no match is found, actions can be taken to prevent the DLL from executing. 

An initial thought could be to undo the internal \syscall{ZwMapViewOfSection} / \syscall{NtMapViewOfSection} function that loaded the DLL into memory by calling it's counter pair \syscall{ZwUnmapViewOfSection} / \syscall{NtUnmapViewOfSection} and thus removing the DLL from memory. The idea is great, but will not succeed as a special lock is hold, the LdrLoadLoaderLock, that can't be accessed at this point of code. Calling the functions regardless will deadlock the driver and soon after deadlock the whole system.

Thus, the DLL will only get patched, rendering it, although still residing in memory, useless. To do that, three points in memory receive modifications: the entry point address, the \syscall{DOS MZ header}, which describes the file format of a DLL with many meta information and the entry point function. The entry point address is set to NULL, the entry point function will get patched with a single \syscall{ret} (0xC3) instruction to prevent execution and the memory containing the \syscall{DOS MZ header} will get zeroed. All three steps guarantee, that nothing will be able to execute from this memory mapped DLL file and thus preventing the typical DLL injections from \syscall{SetWindowsHookEx}, the registry or other techniques.