\section{Conclusion and Future work}
\label{sec:futurework}
This chapter summarizes the thesis, draws a conclusion and includes the limitations of the proposed solution. After that an outline is given for potential future work.
\subsection{Summary}
The thesis has introduced a kernelmode driver to tackle the problem of \gls{PMT}. The different kinds of attacks have been grouped in two categories, external and internal modifications. As such, they were handled separately when designing the architecture of the proposed solution. \gls{WPM} and \gls{DLL} component have been introduced to handle the respective memory tampering and \gls{DLL} injection attacks. Section~\ref{sec:performance}~and~\ref{sec:security} analyzed the performance and security of the proposed solution. While the \gls{WPM} component resulted in almost no overhead, running the \gls{DLL} component resulted in a huge performance hit. During execution of the \gls{DLL} component, the process gets suspended for the time a sha256 hash is generated. It was found out, that the required time scales exponentially with the file size. The performance overhead is therefore the first limitation of the proposed solution. Security analysis outlined that the attacker can not bypass the driver from restricting his actions, given certain conditions. The first condition is that the privilege level of the attacker may not be higher than user privileges (i.e., no admin privileges). The second condition is, that identification of the process which should receive \gls{PMT} protection must be ensured (i.e., the attacker is not allowed to rename the process executable file name). All three limitations can possibly be solved by further research in this area.
\subsection{Future work}
This section will give an outline about possible future research involving this thesis and \gls{PMT}.
\subsubsection{DLL hash caching}
The proposed solution has a performance overhead during \gls{DLL} hashing. This is because every \gls{DLL} might get hashed multiple times, despite no actual changes to the file. In some cases, the \gls{DLL} might also get hashed multiple for the same process. Future research could develop a method to cache the generated \gls{DLL} sha256 hash. The overhead of the \gls{DLL} component will get significantly reduced, making hashing a one time cost until file changes are recognized. 
\subsubsection{Process identification}
Identification of a process is not easily possible in the current solution. The proposed solution uses the executable's file name which can be changed by the attacker. Even generating a hash over this file will not be enough to identify the process that should receive \gls{PMT} protection. Future research could develop a method to identify a process based on a stronger heuristic than file name or file hash. This will make the proposed solution harder to bypass.
\subsubsection{Driver extension to other processes}
The proposed solution currently only works for \emph{Google Chrome}. The driver uses hard coded values to identify a \emph{Chrome} process and will not work on other processes without further extension. Future research could develop a method to apply \gls{PMT} protection to other processes by introducing a standardize specification that allows to protect multiple independent processes. The specification could be deployed by the application vendors to make use of the installed driver. The implementation must ensure, that the specification will not be compromised by an attacker.
\subsubsection{Driver to process communication}
Updating of an application like \emph{Google Chrome} is currently not possible because the proposed solution uses a hard coded whitelist. A dynamic whitelist would be beneficial but will require communication between the driver and the application. Future research could develop a method for safe communication between driver and application. This will allow on-the-fly updating of application. Communication between driver and application will thus reduce the number of \glspl{DLL} that need to be hashed.