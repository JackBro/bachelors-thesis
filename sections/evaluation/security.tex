\subsection{Security}
The driver, given the previously mentioned limitations, increases security to a maximum in a user mode, non admin privileges environment, and the taken actions can't be prevented. To display an in depth evaluation of security, all three main parts of the driver, the process tree, the \syscall{WriteProcessMemory} block and the DLL load block will be checked separately.
To measure the security of \syscall{WriteProcessMemory}, the underlying process tree structure needs to be looked at. A possible attack might make use of reusing a pid that was assigned to a previously existing chrome process. The attacker might achieve this by flooding the system with many small processes, and by chance receiving the right pid from the system. However, the attacker will not be able to fool the process tree structure, as exiting processes are removed and pid reassignment therefore is not an issue. A second attack on the process tree might involve changing the attacking executable filename to chrome.exe, to be added to the list structure. Again, this will not grant the attacker any benefit. The tree maps child processes uniquely to a parent pid. As both the fake and the real process are put into different list structures, they receive different outgoing pids. Therefore, no access is granted by the following \syscall{WriteProcessMemory} call. At last, the tree can't be changed from user mode, because the driver is running in kernel mode and user mode processes don't have access to the virtual memory of the driver. By that, the process tree structure can be considered as secure. This result directly leads to the evaluation of the registered callback to prevent attacks via \syscall{WriteProcessMemory}. The permissions are by default removed, unless one of the following condition holds:
\begin{itemize}
\item Opened and Current process are equal -> self access
\item Opened and Current process pids are equal -> self access
\item Opened and Current process share the same pid according to the process tree
\end{itemize}
The first two points are quiet logical, as the process might call \syscall{WriteProcessMemory} on itself and this modification has to be allowed in all cases. The third point forces the driver to check the existing process tree structure. The results of a \syscall{FindPidInTree} call on opened and current process need to be equal, or otherwise no access can be granted. Due to the fact, that the process tree structure has already been evaluated and was considered secure, \syscall{WriteProcessMemory} is also blocked in all not allowed cases. Finally the third part has to be evaluated to make sure that all previously mentioned attacks will be prevented. As \syscall{PsSetLoadImageNotifyRoutine} is called whenever a DLL was mapped into virtual memory and suspending the process, no execution can occur until the callback has finished. With respect to generating the required sha256 hash, the driver is very restrictive and if a required function call fails, access is denied. Only in cases where a matching entry inside the whitelist is found, access is granted. Therefore, DLLs not on the whitelist will get blocked in all other cases. Because of that, any of the previously mentioned attacks like DLL injection or using \syscall{SetWindowsHookEx} will no longer work. As a result, the driver can be considered secure and code injection attacks are successfully prevented.