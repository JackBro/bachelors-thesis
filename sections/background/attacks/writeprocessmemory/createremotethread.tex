\paragraph{\syscall{CreateRemoteThread} DLL Injection}
DLLs can be loaded into a target process by loading its path into the target memory with \syscall{WriteProcessMemory} and creating a new thread via \syscall{CreateRemoteThread} that calls \syscall{LoadLibrary}. This kind of attack can be used on any process running under the same integrity level and therefore is very widely used in game cheating. At first, a handle to the target process is requested via \syscall{OpenProcess} with \syscall{PROCESS\_VM\_WRITE} and \syscall{PROCESS\_VM\_OPERATION} access rights, which are required to execute the \syscall{WriteProcessMemory} function. If the permissions are missing, \syscall{WriteProcessMemory} is not able to modify the virtual memory of the target process. Virtual memory protection flags do not have to be changed manually, as this is already happening inside \syscall{WriteProcessMemory}. After that, a large enough amount of memory is allocated inside the target process with \syscall{VirtualAllocEx}, to hold the full path of the DLL. Next \syscall{WriteProcessMemory} is used to transfer the DLL path into the target memory space and finally the injection can be completed by calling \syscall{CreateRemoteThread}, which finally loads the DLL with the \syscall{LoadLibrary} function. The allocated memory segment is used as a parameter for the \syscall{LoadLibrary} function call. With the now loaded DLL, arbitrary code can get executed by the DLL, either via using \syscall{CreateRemoteThread} again or via the DLLs entry point.
An example of a basic DLL injection using \syscall{WriteProcessMemory} and \syscall{CreateRemoteThread} can be found in appendix \ref{appendix:writeprocessmemory}. Again, chrome shows no existing defense mechanisms against direct memory modification.