\subsubsection{\syscall{SetWindowsHookEx} injection}
A more reliable way than registry based injection is using the \syscall{SetWindowsHookEx} function of the Windows API. It requires no special privileges to be executed and can be used to only hook into a specific application or being system wide. A hook in this context is a callback function that gets executed whenever a certain event is occurring. In terms of \syscall{SetWindowsHookEx}, there are according to the MSDN \cite{msdn_setwindowshookex} 15 different possible types of events that can be registered for, of which some can only be system wide. The hook procedure that is required as parameter for \syscall{SetWindowsHookEx} has to be located in a DLL file. The DLL to be injected is loaded inside the current process to locate the address of the callback function. An example code is shown in Appendix \ref{appendix:setwindowshookex}. As this attack is also a based on DLL injections the attack tree of Figure \ref{fig:attacks_external} list this attack under external modifications. 

The DLL will not get loaded into the target process until the event is triggered and the registered hook is called for the first time. The callback procedure gives different opportunities to make use of this just created situation. An additional thread can be started from the callback procedure or the called driver entry function to make the injection independent of hook callback function. As this module and especially any created thread are running the context of the remote process, the DLL code has now full access on the process virtual memory. Internal memory modifications can now be performed which will get explained in detail in Section \ref{sec:internal_modifications}. As well as for registry injection, chrome doesn't prevent \syscall{SetWindowsHookEx} DLL injections.