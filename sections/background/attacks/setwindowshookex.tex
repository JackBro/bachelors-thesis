\subsubsection{\syscall{SetWindowsHookEx} Injection}
Another way besides \emph{Registry} based injections is using the \syscall{SetWindowsHookEx} function of the \emph{Windows} \gls{API} to inject a \gls{DLL} file. It requires no special privileges to be executed and can be used to  hook into a specific application or being system wide. A hook in this context is a callback function that gets executed whenever a certain event is occurring. In terms of \syscall{SetWindowsHookEx}, there are according to the \gls{MSDN} \cite{msdn_setwindowshookex} 15 different possible types of events that can be registered for, of which some can only be system wide. The hook procedure that is required as parameter for \syscall{SetWindowsHookEx} has to be located in a \gls{DLL} file. The \gls{DLL} to be injected is loaded by the operating system into the current process, to make the specified callback function available. An example code is shown in Appendix~\ref{appendix:setwindowshookex}. As this attack is also a based on \gls{DLL} injections the attack tree of Figure~\ref{fig:attacks_external} lists this attack under [1.2.2] in external modifications. 

\medskip

The \gls{DLL} will not get loaded into the target process until the event is triggered and the registered hook is called for the first time. The callback procedure gives different opportunities to make use of this created situation. An additional thread can be started from the callback procedure or the called driver entry function to make the injection independent of the hook callback function. As this module and especially any created thread are running in the context of the remote process, the \gls{DLL} code has full access to the process' memory. Internal memory modifications can be performed which will get explained in Section \ref{sec:internal_modifications}. As well as for \emph{Registry} based injections, \emph{Google Chrome} does not prevent \syscall{SetWindowsHookEx} \gls{DLL} injections.