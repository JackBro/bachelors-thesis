\subsubsection{Registry based injection}
Registry based injection uses a special registry key\footnote{The registry key can be found at: HKEY\_LOCAL\_MACHINE\textbackslash Software\textbackslash Microsoft\textbackslash Windows NT\textbackslash CurrentVersion\textbackslash Windows} that can be used to inject DLL files into almost any process. For that reason the shown attack tree in Figure \ref{fig:attacks_external} lists this technique under the group of DLL injections. It is arguable if this attack is an external or internal modification and should therefore be listed in Figure \ref{fig:attacks_internal}. This listing is based on the initial start point of an attack and this is in case of registry based injection outside of the targets process virtual memory space. DLLs can be added by writing the full path to the DLL file into this registry key, with multiple paths separated by semicolons. To make this injection technique work, two conditions have to apply.
\begin{enumerate}
\item The DLL file is having a security descriptor that allows execution. Otherwise the DLL will not get loaded into the target process.
\item The MSDN\cite{msdn_appinitdlls} lists the usage of \syscall{User32.dll} in the target process as a requirement or otherwise the DLLs listed in the registry will not get loaded.
\end{enumerate}
However, these two conditions are quiet easily to fulfill. The first condition is by default true, because the default security descriptor on DLL files allow execution. It requires active interaction by other programs or the user to change this settings. The second condition is most of the time fulfilled. \syscall{User32.dll} is used in almost every process and in general it can be assumed that the MSDN requirement is fulfilled. To make this attack work, a second registry key \syscall{LoadAppInit\_DLLs} has to be changed to value 1, in order to activate this registry based injection. By default this value is set to 0 and cannot be changed without admin privileges.
Defending against this kind of attack is comparably easy, by checking \syscall{AppInit\_DLLs} value and enumerating all loaded modules (DLLs). If a match is found and considered to be unwanted, it can be unloaded or as a safety measurement the application is terminated. As for Google Chrome, there is no validation currently in place and registry based injection can be used to load arbitrary DLL files.