\subsubsection{Data Execution Prevention}
The second existing defense prevents code execution from data memory pages by setting a special \syscall{No Execute bit} \cite{msdn_dep} in hardware onto the memory page. This protection is done by default for every started process. A process will allocate a certain number of memory pages, of which one part is used for the code, and the other for the data. The data sections will automatically get assigned the \syscall{NX bit} and the code pages won't. The attacker might be able to inject code into the data region, but if the application tries to execute code from this place, it is not possible due to the \syscall{NX bit} and an exception is raised leading to an application crash. Thus the attack is prevented and especially buffer overflows can no longer get exploited.

However, for the other attacks based on \syscall{WriteProcessMemory} or DLL injection, this defense mechanism serves no purpose. The attacker can use the Windows API method \syscall{VirtualProtect} \cite{msdn_virtualprotect} to unset the \syscall{NX bit} of data pages and therefore also make use of them for code injection. Additionally, this change might not even be needed. The attacker could do the code injection in a two step manner: 
\begin{enumerate}
\item At first, code is injected into the code region of the process. This is can be defined as loader code.
\item Secondly, code is injected into the data region of the process. This is the actual exploit that should run.
\end{enumerate}
The loader will get executed eventually and unset the \syscall{NX bit} from inside the attacked process, thus execution of the exploit code is now possible. 