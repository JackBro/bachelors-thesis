\subsubsection{Data Execution Prevention}
\label{sec:dep}
The second existing defense prevents code execution from data memory pages by setting a special \syscall{No Execute bit} \cite{msdn_dep} in hardware onto the memory page. This protection is done by default for every started process. A process will allocate a certain number of memory pages, of which one part is used for the code, and the other for the data. The data sections will automatically get assigned the \syscall{NX bit} and the code pages will not. The attacker might be able to inject code into the data region, but if the application tries to execute the injected code, it is not possible due to the \syscall{NX bit} and an exception is raised leading to an application crash. Thus the attack is prevented and especially buffer overflows can no longer get exploited.

However, for the other attacks based on \syscall{WriteProcessMemory} or \gls{DLL} injection, this defense mechanism serves no purpose. The attacker can use the \emph{Windows} \gls{API} method \syscall{VirtualProtect} \cite{msdn_virtualprotect} to unset the \syscall{NX bit} of data pages and therefore also make use of them for code injection. Additionally, this change might not even be needed. The attacker could do the code injection in a two step manner: 
\begin{enumerate}
\item Code is injected into the \emph{code region} of the process. As the main purpose of this code is removing the \syscall{NX bit} of data pages, the resulting code can be much smaller compared to the actual exploit that should be executed.
\item Code is injected into the \emph{data region} of the process. This is the actual exploit that should run.
\item The injected code of Step 1 will get executed by random or can actively be started from outside. The \syscall{NX bit} gets unset and the injected exploit of Step 2 is now executable. The exploit of Step 2 can now be started to complete the attack.
\end{enumerate}