\subsubsection{Adress Space Layout Randomization}
\label{sec:aslr}
\begin{figure}[!htbp]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{sections/background/defenses/aslr.jpg}
\caption{\gls{ASLR} resulting in different DLL memory locations after each boot}
\label{fig:aslr}
\end{figure}
The first of the built in windows defenses is called \gls{ASLR} \cite{miller2009method}. Its main purpose is to randomize memory location for heap, stack and libraries in the virtual address space. This is illustrated in Figure \ref{fig:aslr}, which shows three independent starts of the operating system represented by the three blue vertical bars. On the left, the address space is enumerated from the lowest to the highest possible address. The locations of the loaded \gls{DLL} files is randomized on each start of Windows, and therefore the \glspl{DLL} that can be seen inside each of the three columns have different positions. An attacker that tries to inject code into the application is often dependent on the base address of the stack, heap or libraries. These addresse will no longer be known, due to the applied randomization. Searching inside the virtual address space is not feasible, as it is very large with four gigabyte on a 32 bit and eight terabyte on a 64 bit windows system of virtual addresses. Therefore the attacker might start duplicating his code several times to fill hundreds of addresses and by chance getting his code executed. As the main purpose of \gls{ASLR} is to prevent buffer overflows, it is fulfilling its job by crashing the application due to an illegal memory access on not allocated memory. However, for all possible attacks, \gls{ASLR} will not prevent all exploits \cite{shacham}. All methods involving \gls{WPM} or \gls{DLL} injection can use the Windows \gls{API} function \syscall{GetProcAddress} to retrieve the address of an exported function, making address randomization easy to circumvent. The address has to be known by Windows or otherwise \glspl{DLL} will not server their purpose of sharing exported functions.