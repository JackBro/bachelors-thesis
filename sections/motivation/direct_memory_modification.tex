\subsection{Direct memory modification}
The last possible user-mode injection directly modifies the existing virtual memory of a process and thus is very powerful. It has to be distinguished between modifications from inside and outside of a process. Modification from inside are quite trivial and only require to change the process virtual memory. As this happens from inside, memcpy can be used to retrieve and store code in the virtual memory. Depending on which information should be modified, it can be required to change the virtual memories protection with the built in VirtualProtectEx function. After the modification with memcpy has been completed, the protection should be changed back to it's original value.
In contrast to inside memory tampering, memory modification from outside is a bit harder to do. All other existing injection methods that don't use the priory explained methods have to use WriteProcessMemory from the Windows API. The usage of WriteProcessMemory requires a valid handle to the process with permissions to write into the virtual memory of the process. A valid handle can be retrieved by using OpenProcess and requesting at least PROCESS\_VM\_WRITE and PROCESS\_VM\_OPERATION access rights. If the permissions are missing, WriteProcessMemory is not able to modify the virtual memory of a remote process. Virtual memory protection flags don't have to be changed manually, as this is already happening inside WriteProcessMemory. An attacker can now using either memcpy (inside attack) or WriteProcessMemory (outside attack) change the virtual memory to his behalf. Some methods additionally require to create a remote thread with the Windows APIs CreateRemoteThread function, to start their injected code. An example on a very basic DLL injection using WriteProcessMemory and CreateRemoteThread can be found at \ref{INSERT CODE REF HERE}. Again, chrome shows no existing defense mechanisms against direct memory modification.