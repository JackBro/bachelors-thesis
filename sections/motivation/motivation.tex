\section{Motivation}

Memory process tampering has an always been existing feature on windows computers. Powerful features like API Hooking which can be used for debugging are possible by directly modifying the process memory or indirectly by loading a prepared DLL file. This is achieved by creating a function with the same typed input parameters and return value and placing a jmp instruction at the start of the original function start address. One has now the option to just intercept the call and do extended information validation and logging without modifying the programs behavior or to replace the function call with a completly new output. [INSERT CODE REF HERE] shows an example of this technique. The targets function address is read and it's first instruction is replaced by a jmp instruction. This behavior is already very well implemented in the microsoft detours library\cite{msdetours}.
However, code injection can also be used for various kinds of attacking techniques and provide an easy way to modifiy existing programs behavior. This thesis will specifically look at code injection into the Google Chrome browser on a Windows 7 system and ways to detect and if possible prevent code injections from happening. An attacker might try to change browser settings, replace or add ads or even redirect certain traffic to receive information in a phishing like manner from the enduser. As kernelmode attacks cannot be defended, this thesis will only focus on usermode non admin privilege functioning techniques. There are in total three ways to inject code into any process that aren't blocked by windows itself. The first
uses the registries AppInit\_DLLs key, the second uses SetWindowsHookEx which can globaly hook into nearly any process and the third and most widely used techniques directly modify the targets process memory.

\subsection{AppInit\_DLLs injection}
AppInit\_DLLs injection is the weakest kind of attack and can easily be mitigated. Windows provides a special registry key\footnote{The key can be found at: HKEY\_LOCAL\_MACHINE\textbackslash Software\textbackslash Microsoft\textbackslash Windows NT\textbackslash CurrentVersion\textbackslash Windows} that can be used to add one or multiple paths to DLL files, that should be automatically loaded into starting processes. The MSDN\cite{msdn_appinitdlls} lists the usage of User32.dll in the process as a requirment or otherwise the DLLs listed in the registry will not be loaded. Leaving out User32.dll is nearly impossible, however, since it is used in almost any process and one can assume that the given MSDN requirment is almost always fullfilled. Additonally a second key LoadAppInit\_DLLs has to be changed to 1 in order to activate AppInit\_DLLs injection. By default this value is set to 0 and cannot be changed without admin privileges. Defending against this kind of attack is comparably easy, by checking AppInit\_DLLs value and enumerating all loaded modules. If a match is found and unwanted it can be unloaded or as a safety meassurment the application is terminated. As for Google Chrome, there is no validation currently in place and AppInit\_DLLs can be used to inject arbitrary DLL files.

\subsection{SetWindowsHookEx injection}
A stronger and more reliable way than AppInit\_DLLs injection is using SetWindowsHookEx function of the Windows API. It requires no special privileges and can be set to only hook into a specific application or even being system wide. There are several events available that can be registered for. The DLL to be injected is loaded inside the current process to locate the address of the callback function. A handle to the loaded module and the just retrieved address are then passed as parameters to the SetWindowsHookEx function. An example is shown in \ref{INSERT CODE REF HERE}. The DLL wil not get loaded into the remote process until the registered hook is called for the first time. Once the hook is called, a additional thread can be started to make the injection independent of hook callback function. As this module and especially any created thread are running the context of the remote process, the dll code has now full access on the process virtual memory. Direct memory manipulation can now be performed which will get explained in detail in the next section. As well as for AppInit\_DLLs injection, chrome doesn't prevent SetWindowsHookEx DLL injections.

\subsection{Direct memory modification}
The last possible usermode injection directly modifies the existing virtual memory of a process and thus is very powerful. It has to be distinguished between modifications from inside and outside of a process. Modification from inside are quite trivial and only require to change the process virtual memory. As this happens from inside, memcpy can be used to retrieve and store code in the virtual memory. Depending on which information should be modified, it can be required to change the virtual memories protection with the built in VirtualProtectEx function. After the modification with memcpy has been completed, the protection should be changed back to it's original value.
In contrast to inside memory tampering, memory modifcation from outside is a bit harder to do. All other existing injection methods that don't use the priorly explained methods have to use WriteProcessMemory from the Windows API. The usage of WriteProcessMemory requires a valid handle to the process with permissions to write into the virtual memory of the process. A valid handle can be retrieved by using OpenProcess and requesting at least PROCESS\_VM\_WRITE and PROCESS\_VM\_OPERATION access rights. If the permissions are missing, WriteProcessMemory is not able to modifiy the virtual memory of a remote process. Virtual memory protection flags don't have to be changed manually, as this is already happening inside WriteProcessMemory. An attacker can now using either memcpy (inside attack) or WriteProcessMemory (outside attack) change the virtual memory to his behalf. Some methods additonally require to create a remote thread with the Windows APIs CreateRemoteThread function, to start their injected code. An example on a very basic DLL injection using WriteProcessMemory and CreateRemoteThread can be found at \ref{INSERT CODE REF HERE}. Again, chrome shows no existing defense mechanisms against direct memory modification.