\section{Motivation}
Memory process tampering has an always been existing feature on windows computers. Powerful features like API Hooking which can be used for debugging are possible by directly modifying the process memory or indirectly by loading a prepared DLL file. This is achieved by creating a function with the same typed input parameters and return value and placing a jmp instruction at the start of the original function start address. One has now the option to just intercept the call and do extended information validation and logging without modifying the programs behavior or to replace the function call with a completely new output. [INSERT CODE REF HERE] shows an example of this technique. The targets function address is read and it's first instruction is replaced by a jmp instruction. This behavior is already very well implemented in the Microsoft detours library\cite{msdetours}.
However, code injection can also be used for various kinds of attacking techniques and provide an easy way to modify existing programs behavior. This thesis will specifically look at code injection into the Google Chrome browser on a Windows 7 system and ways to detect and if possible prevent code injections from happening. An attacker might try to change browser settings, replace or add ads or even redirect certain traffic to receive information in a phishing like manner from the end-user. As kernel-mode attacks cannot be defended, this thesis will only focus on user-mode non admin privilege functioning techniques. There are in total three ways to inject code into any process that aren't blocked by windows itself. The first
uses the registries AppInit\_DLLs key, the second uses SetWindowsHookEx which can globally hook into nearly any process and the third and most widely used techniques directly modify the targets process memory.
\input{sections/motivation/appinit_dlls.tex}
\input{sections/motivation/setwindowshookex.tex}
\input{sections/motivation/direct_memory_modification.tex}